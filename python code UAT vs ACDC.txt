import numpy as np
import pandas as pd
from scipy.integrate import quad
from scipy.optimize import minimize_scalar
import os
import matplotlib.pyplot as plt
from matplotlib import rc # Importar rc para habilitar LaTeX en Matplotlib

# Habilitar el uso de LaTeX para una visualizaci√≥n correcta de s√≠mbolos (opcional, pero mejor)
# Descomentar si tienes una distribuci√≥n LaTeX instalada y quieres usar la fuente del sistema
# rc('text', usetex=True) 

# =============================================================================
# 0. CONFIGURACI√ìN INICIAL Y PREPARACI√ìN DE CARPETA
# =============================================================================

FOLDER_NAME = 'UAT_realistic_analysis2_14_10_25'
os.makedirs(FOLDER_NAME, exist_ok=True)
print(f"=== UAT - AN√ÅLISIS DIN√ÅMICO FINAL (CORRECCI√ìN UNICODE) ===")
print(f"Archivos de salida guardados en: {FOLDER_NAME}/\n")

# =============================================================================
# 1. DATOS BAO REALES Y PAR√ÅMETROS BASE
# =============================================================================

# Datos BAO reales agregados (z, DM/rd_obs, DM/rd_err)
df_bao_agg = pd.DataFrame({
    'z': [0.38, 0.51, 0.61, 1.48, 2.33],
    'DM_rd_obs': [10.25, 13.37, 15.48, 26.47, 37.55],
    'DM_rd_err': [0.165, 0.205, 0.215, 0.415, 1.125]
})

# Par√°metros cosmol√≥gicos de referencia (Planck 2018)
class UATParameters:
    H0_low = 67.36      # H0 √≥ptimo para LCDM (CMB)
    H0_high = 73.00     # H0 de medici√≥n local (SH0ES/Cepheidas)
    Om_m = 0.315        # Densidad de Materia total
    Om_de = 0.685       # Densidad de Energ√≠a Oscura
    Om_r = 9.4e-5       # Densidad de Radiaci√≥n
    rd_planck = 147.09  # Horizonte sonoro del LCDM
    c = 299792.458      # Velocidad de la luz (km/s)

params = UATParameters()

# Guardar datos BAO en CSV
df_bao_agg.to_csv(os.path.join(FOLDER_NAME, 'BAO_data_used.csv'), index=False)
print("Datos BAO guardados en BAO_data_used.csv")

# =============================================================================
# 2. DEFINICI√ìN DEL MODELO UAT DIN√ÅMICO (F√≠sica Corregida)
# =============================================================================

def k_scaling_uat(z, k_early, z_trans=2.68):
    """Factor de correcci√≥n cu√°ntica UAT (k_early) en funci√≥n de z."""
    return 1 - (1 - k_early) / 2 * (1 + np.tanh((z - z_trans) / 5))

def E_LCDM(z):
    """Ecuaci√≥n de Expansi√≥n para LambdaCDM (E(z) = H(z)/H0)"""
    return np.sqrt(params.Om_m * (1+z)**3 + params.Om_de + params.Om_r * (1+z)**4)

def E_UAT(z, k_early):
    """Ecuaci√≥n de Expansi√≥n para UAT (CON la correcci√≥n k_scaling)"""
    k = k_scaling_uat(z, k_early)
    return np.sqrt(
        k * params.Om_m * (1+z)**3 +
        k * params.Om_r * (1+z)**4 +
        params.Om_de
    )

def calcular_DM_rd(z, H0, rd, E_model_func, k_early=None):
    """Calcula DM/rd para cualquier modelo de expansi√≥n."""
    
    if E_model_func == E_LCDM:
        E_integrand = lambda z_prime: 1.0 / E_LCDM(z_prime)
    elif E_model_func == E_UAT and k_early is not None:
        E_integrand = lambda z_prime: 1.0 / E_UAT(z_prime, k_early)
    else:
        raise ValueError("Funci√≥n de modelo o par√°metro k_early inv√°lido para UAT.")
        
    integral, _ = quad(E_integrand, 0, z)
    DM = (params.c / H0) * integral
    return DM / rd

def calcular_chi2(H0, rd, E_model_func, k_early=None):
    """Calcula el chi-cuadrado para el ajuste a los datos BAO reales."""
    predicciones = []
    for z in df_bao_agg['z']:
        pred = calcular_DM_rd(z, H0, rd, E_model_func, k_early)
        predicciones.append(pred)
    
    obs = df_bao_agg['DM_rd_obs'].values
    err = df_bao_agg['DM_rd_err'].values
    return np.sum(((obs - predicciones) / err)**2)

# =============================================================================
# 3. AN√ÅLISIS Y OPTIMIZACI√ìN
# =============================================================================

# 1. LCDM √ìptimo (H0=67.36)
chi2_lcdm_optimo = calcular_chi2(params.H0_low, params.rd_planck, E_LCDM)

# 2. LCDM Tensi√≥n (H0=73.00)
chi2_lcdm_tension = calcular_chi2(params.H0_high, params.rd_planck, E_LCDM)

# 3. B√∫squeda de k_early √≥ptimo para UAT (H0=73.00, rd=147.09)
H0_uat = params.H0_high
rd_uat = params.rd_planck 

def chi2_uat_objective(k_early):
    return calcular_chi2(H0_uat, rd_uat, E_UAT, k_early)

resultado_min = minimize_scalar(chi2_uat_objective, bounds=(0.5, 1.0), method='bounded')

k_early_optimo = resultado_min.x
chi2_uat_dinamico = resultado_min.fun

# =============================================================================
# 4. GENERACI√ìN DE RESULTADOS Y ARCHIVOS DE SALIDA
# =============================================================================

# 4.1 Generar DataFrame de Comparaci√≥n de Predicciones
pred_lcdm = [calcular_DM_rd(z, params.H0_low, params.rd_planck, E_LCDM) for z in df_bao_agg['z']]
pred_uat = [calcular_DM_rd(z, H0_uat, rd_uat, E_UAT, k_early_optimo) for z in df_bao_agg['z']]

df_comparacion = df_bao_agg.copy()
df_comparacion['DM_rd_LCDM_pred'] = pred_lcdm
df_comparacion['DM_rd_UAT_pred'] = pred_uat
df_comparacion['Residual_UAT (obs-pred)'] = df_comparacion['DM_rd_obs'] - df_comparacion['DM_rd_UAT_pred']
df_comparacion['Residual_UAT_sigma'] = df_comparacion['Residual_UAT (obs-pred)'] / df_comparacion['DM_rd_err']

# Guardar Comparaci√≥n en CSV
df_comparacion.to_csv(os.path.join(FOLDER_NAME, 'Predicciones_UAT_vs_LCDM.csv'), index=False)
print("Resultados detallados guardados en Predicciones_UAT_vs_LCDM.csv")


# 4.2 Generar An√°lisis Ejecutivo (TXT)
# SOLUCI√ìN: Usar encoding='utf-8' al abrir el archivo.
with open(os.path.join(FOLDER_NAME, 'Analisis_Ejecutivo.txt'), 'w', encoding='utf-8') as f:
    f.write("="*70 + "\n")
    f.write("AN√ÅLISIS EJECUTIVO - UAT DIN√ÅMICO (14-OCT-25)\n")
    f.write("="*70 + "\n\n")
    
    f.write("1. PAR√ÅMETROS DE REFERENCIA:\n")
    f.write(f"   H0 (Tensi√≥n Local): {H0_uat:.2f} km/s/Mpc\n")
    f.write(f"   rd (Planck Inicial): {rd_uat:.2f} Mpc\n\n")

    f.write("2. RESULTADOS DE MINIMIZACI√ìN:\n")
    f.write(f"   k_early √ìptimo (UAT): {k_early_optimo:.4f}\n")
    f.write(f"   Correcci√≥n Primordial: {(1.0 - k_early_optimo) * 100:.2f}%\n\n")
    
    f.write("3. COMPARATIVA DE AJUSTE (Chi-Cuadrado):\n")
    # Usamos el s√≠mbolo chi-cuadrado (œá¬≤)
    f.write(f"   (1) LCDM √ìptimo (H0={params.H0_low:.2f}): œá¬≤ = {chi2_lcdm_optimo:.3f}\n")
    f.write(f"   (2) LCDM Tensi√≥n (H0={params.H0_high:.2f}): œá¬≤ = {chi2_lcdm_tension:.3f}\n")
    f.write(f"   (3) UAT Soluci√≥n Din√°mica: œá¬≤ = {chi2_uat_dinamico:.3f}\n\n")

    f.write("4. CONCLUSI√ìN:\n")
    delta_chi2 = chi2_lcdm_optimo - chi2_uat_dinamico
    
    if chi2_uat_dinamico <= chi2_lcdm_optimo:
        f.write("üéâ ¬°√âXITO CIENT√çFICO! UAT RESUELVE LA TENSI√ìN H‚ÇÄ\n")
        f.write(f"   El UAT (con H0={H0_uat:.2f}) ajusta los datos BAO mejor que el LCDM √≥ptimo.\n")
        f.write(f"   Mejora estad√≠stica (Œîœá¬≤ vs LCDM √ìptimo): +{delta_chi2:.3f}\n")
        f.write(f"   Requisito F√≠sico: El Universo temprano debe tener una expansi√≥n {(1.0 - k_early_optimo) * 100:.2f}% menor.\n")
    else:
        f.write("‚úÖ UAT MEJORA SIGNIFICATIVAMENTE\n")
        f.write(f"   Mejora vs tensi√≥n (Œîœá¬≤): {chi2_lcdm_tension - chi2_uat_dinamico:+.3f}\n")
        f.write("   Requiere m√°s refinamiento en la funci√≥n k_scaling(z).\n")

print("An√°lisis Ejecutivo guardado en Analisis_Ejecutivo.txt")

# 4.3 Generar Gr√°fico de Expansi√≥n (PNG)
z_range = np.linspace(0, 3, 100)
E_lcdm_vals = [E_LCDM(z) for z in z_range]
E_uat_vals = [E_UAT(z, k_early_optimo) for z in z_range]

plt.figure(figsize=(10, 6))
# SOLUCI√ìN: Usar una cadena cruda (r'') para el t√≠tulo y la etiqueta
plt.plot(z_range, E_lcdm_vals, 'r-', label=r'$\Lambda$CDM Expansi√≥n Est√°ndar', linewidth=2) 
plt.plot(z_range, E_uat_vals, 'b--', label=f'UAT Expansi√≥n Modificada (k={k_early_optimo:.4f})', linewidth=2)
plt.axvline(x=2.68, color='k', linestyle=':', label='z de Transici√≥n (Hip√≥tesis)')

plt.xlabel('Redshift (z)')
plt.ylabel(r'$E(z) = H(z)/H_0$')
# Usamos r'' para evitar el SyntaxWarning con \L
plt.title(r'Diferencia de la Expansi√≥n: UAT (k_{early}='+f'{k_early_optimo:.4f}'+r') vs $\Lambda$CDM')
plt.legend()
plt.grid(True, alpha=0.3)
plt.savefig(os.path.join(FOLDER_NAME, 'Expansi√≥n_UAT_vs_LCDM.png'), dpi=300, bbox_inches='tight')
# plt.show() # Descomentar para ver en tiempo real en Jupyter
print("Gr√°fico de Expansi√≥n guardado en Expansi√≥n_UAT_vs_LCDM.png")

print("\n=== PROCESO COMPLETADO ===")